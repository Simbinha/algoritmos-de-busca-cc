<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problema de Busca - Algoritmos de Grafos</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .image-container {
            text-align: center;
            margin: 20px 0 30px;
        }
        
        .image-container img {
            max-width: 100%;
            height: auto;
        }
        
        .form-container {
            background-color: #f4f4f4;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        select, input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .button-group {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        #result-container {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            background-color: #f9f9f9;
        }
        
        #path, #cost {
            margin: 10px 0;
        }
        
        #path {
            font-weight: bold;
        }
        
        .hidden {
            display: none;
        }
        
        .param-container {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-radius: 4px;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Problema de Busca - Mapa da Romênia</h1>
    
    <div class="image-container">
        <img src="/api/placeholder/600/450" alt="Mapa das cidades da Romênia com distâncias">
    </div>
    
    <div class="form-container">
        <div class="form-group">
            <label for="start">Cidade de Partida:</label>
            <select id="start">
                <option value="">Selecione uma cidade</option>
            </select>
        </div>
        
        <div class="form-group">
            <label for="end">Cidade de Destino:</label>
            <select id="end">
                <option value="">Selecione uma cidade</option>
            </select>
        </div>
        
        <div class="form-group">
            <label for="algorithm">Algoritmo:</label>
            <select id="algorithm">
                <option value="">Selecione um algoritmo</option>
                <option value="bfs">BFS - Busca em Largura</option>
                <option value="dfs">DFS - Busca em Profundidade</option>
                <option value="ucs">UCS - Busca de Custo Uniforme</option>
                <option value="dls">DLS - Busca em Profundidade Limitada</option>
                <option value="iddfs">IDDFS - Busca de Aprofundamento Iterativo</option>
                <option value="greedy">Greedy - Busca Gulosa</option>
                <option value="astar">A* - A-Star</option>
            </select>
        </div>
        
        <div id="dls-params" class="param-container">
            <label for="depth-limit">Limite de Profundidade:</label>
            <input type="number" id="depth-limit" min="1" value="3">
        </div>
        
        <div id="iddfs-params" class="param-container">
            <label for="max-depth">Profundidade Máxima:</label>
            <input type="number" id="max-depth" min="1" value="10">
        </div>
        
        <div class="button-group">
            <button id="search-btn">Buscar Caminho</button>
            <button id="clear-btn">Limpar</button>
        </div>
    </div>
    
    <div id="result-container" class="hidden">
        <h3>Resultado:</h3>
        <div id="path">Caminho encontrado: </div>
        <div id="cost">Custo total: </div>
        <div id="details"></div>
    </div>
    
    <script>
// Algoritmos de busca com nomes em português brasileiro

function buscaEmLargura(start, end) {
    const frontier = [{node: start, path: [start]}];
    const explored = new Set();
    
    while (frontier.length) {
        const current = frontier.shift();
        
        if (current.node === end) {
            return {
                path: current.path,
                cost: calculateTotalCost(current.path)
            };
        }
        
        if (!explored.has(current.node)) {
            explored.add(current.node);
            Object.keys(graph[current.node]).forEach(neighbor => {
                if (!explored.has(neighbor)) {
                    frontier.push({
                        node: neighbor,
                        path: [...current.path, neighbor]
                    });
                }
            });
        }
    }
    return null;
}

function buscaEmProfundidade(start, end) {
    function explorar(node, target, currentPath = [], visited = new Set()) {
        currentPath = [...currentPath, node];
        visited.add(node);
        
        if (node === target) {
            return currentPath;
        }
        
        for (let nextCity in graph[node]) {
            if (!visited.has(nextCity)) {
                const result = explorar(nextCity, target, currentPath, new Set(visited));
                if (result) return result;
            }
        }
        return null;
    }
    
    const path = explorar(start, end);
    return path ? {path, cost: calculateTotalCost(path)} : null;
}

function buscaDeCustoUniforme(start, end) {
    const priorityQueue = [{node: start, cost: 0, path: [start]}];
    const seen = new Map();
    
    while (priorityQueue.length) {
        priorityQueue.sort((a, b) => a.cost - b.cost);
        const {node, cost, path} = priorityQueue.shift();
        
        if (node === end) {
            return {path, cost};
        }
        
        if (!seen.has(node) || seen.get(node) > cost) {
            seen.set(node, cost);
            Object.entries(graph[node]).forEach(([neighbor, distance]) => {
                priorityQueue.push({
                    node: neighbor,
                    cost: cost + distance,
                    path: [...path, neighbor]
                });
            });
        }
    }
    return null;
}

function buscaEmProfundidadeLimitada(start, end, maxDepth) {
    function dlsRecursiva(node, target, depth, path = [], visited = new Set()) {
        path.push(node);
        
        if (node === target) return path;
        if (depth <= 0) return null;
        
        visited.add(node);
        
        for (let neighbor in graph[node]) {
            if (!visited.has(neighbor)) {
                const result = dlsRecursiva(neighbor, target, depth - 1, [...path], new Set(visited));
                if (result) return result;
            }
        }
        return null;
    }
    
    const path = dlsRecursiva(start, end, maxDepth);
    return path ? {path, cost: calculateTotalCost(path)} : null;
}

function buscaDeAprofundamentoIterativo(start, end, maxDepth) {
    let result = null;
    for (let depth = 0; depth <= maxDepth && !result; depth++) {
        result = buscaEmProfundidadeLimitada(start, end, depth);
    }
    return result;
}

function buscaGulosa(start, end) {
    const openList = [{node: start, h: heuristic[start], path: [start]}];
    const closedList = new Set();
    
    while (openList.length) {
        openList.sort((a, b) => a.h - b.h);
        const current = openList.shift();
        
        if (current.node === end) {
            return {
                path: current.path,
                cost: calculateTotalCost(current.path)
            };
        }
        
        if (!closedList.has(current.node)) {
            closedList.add(current.node);
            Object.keys(graph[current.node]).forEach(neighbor => {
                if (!closedList.has(neighbor)) {
                    openList.push({
                        node: neighbor,
                        h: heuristic[neighbor],
                        path: [...current.path, neighbor]
                    });
                }
            });
        }
    }
    return null;
}

function buscaAEstrela(start, end) {
    const open = new Map([[start, {cost: 0, h: heuristic[start], path: [start]}]]);
    const closed = new Map();
    
    while (open.size) {
        let currentNode = [...open.entries()].reduce((a, b) => 
            (a[1].cost + a[1].h) < (b[1].cost + b[1].h) ? a : b
        )[0];
        
        const current = open.get(currentNode);
        open.delete(currentNode);
        
        if (currentNode === end) {
            return {path: current.path, cost: current.cost};
        }
        
        closed.set(currentNode, current);
        
        Object.entries(graph[currentNode]).forEach(([neighbor, distance]) => {
            const gScore = current.cost + distance;
            const hScore = heuristic[neighbor];
            
            if (!closed.has(neighbor) || gScore < closed.get(neighbor).cost) {
                if (!open.has(neighbor) || gScore < open.get(neighbor).cost) {
                    open.set(neighbor, {
                        cost: gScore,
                        h: hScore,
                        path: [...current.path, neighbor]
                    });
                }
            }
        });
    }
    return null;
}

// Descrições dos algoritmos em português brasileiro
const algorithmDescriptions = {
    bfs: "Busca em Largura (BFS): Explora todas as cidades vizinhas de forma nivelada, garantindo o menor número de conexões até o destino.",
    dfs: "Busca em Profundidade (DFS): Segue um caminho até o fim antes de retroceder, explorando profundamente cada ramificação.",
    ucs: "Busca de Custo Uniforme (UCS): Encontra o caminho de menor custo total, considerando as distâncias reais entre cidades.",
    dls: "Busca em Profundidade Limitada (DLS): Similar ao DFS, mas restringe a profundidade de exploração a um limite específico.",
    iddfs: "Busca de Aprofundamento Iterativo (IDDFS): Combina vantagens do BFS e DFS, aumentando gradualmente o limite de profundidade.",
    greedy: "Busca Gulosa (Greedy): Escolhe o próximo passo baseado apenas na distância estimada até o destino (heurística).",
    astar: "A* (A-Star): Encontra o caminho ótimo combinando o custo real percorrido com uma estimativa heurística do destino."
};

// Modificar o evento do botão de busca para usar os novos nomes
document.getElementById('search-btn').addEventListener('click', function() {
    const start = document.getElementById('start').value;
    const end = document.getElementById('end').value;
    const algorithm = document.getElementById('algorithm').value;
    const resultContainer = document.getElementById('result-container');
    const pathEl = document.getElementById('path');
    const costEl = document.getElementById('cost');
    const detailsEl = document.getElementById('details');
    
    if (!start || !end || !algorithm) {
        alert('Por favor, selecione a cidade de partida, destino e um algoritmo');
        return;
    }
    
    if (!validateInput(start, end)) return;
    
    let result = null;
    
    switch (algorithm) {
        case 'bfs':
            result = buscaEmLargura(start, end);
            break;
        case 'dfs':
            result = buscaEmProfundidade(start, end);
            break;
        case 'ucs':
            result = buscaDeCustoUniforme(start, end);
            break;
        case 'dls':
            const limit = parseInt(document.getElementById('depth-limit').value) || 3;
            result = buscaEmProfundidadeLimitada(start, end, limit);
            break;
        case 'iddfs':
            const maxDepth = parseInt(document.getElementById('max-depth').value) || 10;
            result = buscaDeAprofundamentoIterativo(start, end, maxDepth);
            break;
        case 'greedy':
            result = buscaGulosa(start, end);
            break;
        case 'astar':
            result = buscaAEstrela(start, end);
            break;
    }
    
    detailsEl.textContent = algorithmDescriptions[algorithm] || "";
    
    if (result) {
        pathEl.textContent = "Caminho encontrado: " + result.path.join(' → ');
        costEl.textContent = `Custo total: ${result.cost} km`;
        resultContainer.classList.remove('hidden');
    } else {
        pathEl.textContent = "Nenhum caminho encontrado";
        costEl.textContent = "";
        resultContainer.classList.remove('hidden');
    }
});
    </script>
</body>
</html>
