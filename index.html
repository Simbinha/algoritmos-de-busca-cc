<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Problema de Busca - Algoritmos de Grafos</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .image-container {
            text-align: center;
            margin: 20px 0 30px;
        }
        
        .image-container img {
            max-width: 100%;
            height: auto;
        }
        
        .form-container {
            background-color: #f4f4f4;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .form-group {
            margin-bottom: 15px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        
        select, input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .button-group {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        
        button {
            padding: 10px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        #result-container {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            background-color: #f9f9f9;
        }
        
        #path, #cost {
            margin: 10px 0;
        }
        
        #path {
            font-weight: bold;
        }
        
        .hidden {
            display: none;
        }
        
        .param-container {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border-radius: 4px;
            display: none;
        }
    </style>
</head>
<body>
    <h1>Problema de Busca - Mapa da Romênia</h1>
    
    <div class="image-container">
        <img src="/api/placeholder/600/450" alt="Mapa das cidades da Romênia com distâncias">
    </div>
    
    <div class="form-container">
        <div class="form-group">
            <label for="start">Cidade de Partida:</label>
            <select id="start">
                <option value="">Selecione uma cidade</option>
            </select>
        </div>
        
        <div class="form-group">
            <label for="end">Cidade de Destino:</label>
            <select id="end">
                <option value="">Selecione uma cidade</option>
            </select>
        </div>
        
        <div class="form-group">
            <label for="algorithm">Algoritmo:</label>
            <select id="algorithm">
                <option value="">Selecione um algoritmo</option>
                <option value="bfs">BFS - Busca em Largura</option>
                <option value="dfs">DFS - Busca em Profundidade</option>
                <option value="ucs">UCS - Busca de Custo Uniforme</option>
                <option value="dls">DLS - Busca em Profundidade Limitada</option>
                <option value="iddfs">IDDFS - Busca de Aprofundamento Iterativo</option>
                <option value="greedy">Greedy - Busca Gulosa</option>
                <option value="astar">A* - A-Star</option>
            </select>
        </div>
        
        <div id="dls-params" class="param-container">
            <label for="depth-limit">Limite de Profundidade:</label>
            <input type="number" id="depth-limit" min="1" value="3">
        </div>
        
        <div id="iddfs-params" class="param-container">
            <label for="max-depth">Profundidade Máxima:</label>
            <input type="number" id="max-depth" min="1" value="10">
        </div>
        
        <div class="button-group">
            <button id="search-btn">Buscar Caminho</button>
            <button id="clear-btn">Limpar</button>
        </div>
    </div>
    
    <div id="result-container" class="hidden">
        <h3>Resultado:</h3>
        <div id="path">Caminho encontrado: </div>
        <div id="cost">Custo total: </div>
        <div id="details"></div>
    </div>
    
    <script>
        // Grafo das cidades e distâncias
        const graph = {
            'Arad': {'Zerind': 75, 'Sibiu': 140, 'Timisoara': 118},
            'Zerind': {'Arad': 75, 'Oradea': 71},
            'Oradea': {'Zerind': 71, 'Sibiu': 151},
            'Sibiu': {'Arad': 140, 'Oradea': 151, 'Fagaras': 99, 'RimnicuVilcea': 80},
            'Timisoara': {'Arad': 118, 'Lugoj': 111},
            'Lugoj': {'Timisoara': 111, 'Mehadia': 70},
            'Mehadia': {'Lugoj': 70, 'Drobeta': 75},
            'Drobeta': {'Mehadia': 75, 'Craiova': 120},
            'Craiova': {'Drobeta': 120, 'RimnicuVilcea': 146, 'Pitesti': 138},
            'RimnicuVilcea': {'Sibiu': 80, 'Craiova': 146, 'Pitesti': 97},
            'Fagaras': {'Sibiu': 99, 'Bucharest': 211},
            'Pitesti': {'RimnicuVilcea': 97, 'Craiova': 138, 'Bucharest': 101},
            'Bucharest': {'Fagaras': 211, 'Pitesti': 101, 'Giurgiu': 90, 'Urziceni': 85},
            'Giurgiu': {'Bucharest': 90},
            'Urziceni': {'Bucharest': 85, 'Hirsova': 98, 'Vaslui': 142},
            'Hirsova': {'Urziceni': 98, 'Eforie': 86},
            'Eforie': {'Hirsova': 86},
            'Vaslui': {'Urziceni': 142, 'Iasi': 92},
            'Iasi': {'Vaslui': 92, 'Neamt': 87},
            'Neamt': {'Iasi': 87}
        };
        
        // Valores heurísticos (distância em linha reta até Bucharest)
        const heuristic = {
            'Arad': 366,
            'Zerind': 374,
            'Oradea': 380,
            'Sibiu': 253,
            'Timisoara': 329,
            'Lugoj': 244,
            'Mehadia': 241,
            'Drobeta': 242,
            'Craiova': 160,
            'RimnicuVilcea': 193,
            'Fagaras': 176,
            'Pitesti': 100,
            'Bucharest': 0,
            'Giurgiu': 77,
            'Urziceni': 80,
            'Hirsova': 151,
            'Eforie': 161,
            'Vaslui': 199,
            'Iasi': 226,
            'Neamt': 234
        };
        
        // Preencher os dropdowns de cidades
        function populateCityDropdowns() {
            const cities = Object.keys(graph).sort();
            const startSelect = document.getElementById('start');
            const endSelect = document.getElementById('end');
            
            cities.forEach(city => {
                startSelect.innerHTML += `<option value="${city}">${city}</option>`;
                endSelect.innerHTML += `<option value="${city}">${city}</option>`;
            });
            
            // Valores padrão
            startSelect.value = 'Arad';
            endSelect.value = 'Bucharest';
        }
        
        // Mostrar parâmetros adicionais com base no algoritmo selecionado
        document.getElementById('algorithm').addEventListener('change', function() {
            const algorithm = this.value;
            const dlsParams = document.getElementById('dls-params');
            const iddfsParams = document.getElementById('iddfs-params');
            
            dlsParams.style.display = algorithm === 'dls' ? 'block' : 'none';
            iddfsParams.style.display = algorithm === 'iddfs' ? 'block' : 'none';
        });
        
        // Funções de validação
        function validateInput(start, end) {
            if (!graph[start] || !graph[end]) {
                alert("Cidade de partida ou chegada inválida. Verifique os nomes.");
                return false;
            }
            return true;
        }
        
        // Funções utilitárias
        function calculateTotalCost(path) {
            if (!path || path.length < 2) return 0;
            
            let totalCost = 0;
            for (let i = 0; i < path.length - 1; i++) {
                const current = path[i];
                const next = path[i + 1];
                totalCost += graph[current][next];
            }
            return totalCost;
        }
        
        // Algoritmos de busca
        function bfs(start, end) {
            const queue = [[start, [start]]];  // [node, path]
            const visited = new Set();
            
            while (queue.length > 0) {
                const [node, path] = queue.shift();
                
                if (node === end) {
                    return {
                        path: path,
                        cost: calculateTotalCost(path)
                    };
                }
                
                if (!visited.has(node)) {
                    visited.add(node);
                    for (const neighbor in graph[node]) {
                        if (!visited.has(neighbor)) {
                            queue.push([neighbor, [...path, neighbor]]);
                        }
                    }
                }
            }
            return null;
        }
        
        function dfs(start, end, path = [], visited = new Set(), cost = 0) {
            path.push(start);
            
            if (start === end) {
                return {path: [...path], cost};
            }
            
            visited.add(start);
            
            for (const neighbor in graph[start]) {
                if (!visited.has(neighbor)) {
                    const result = dfs(neighbor, end, [...path], new Set([...visited]), cost + graph[start][neighbor]);
                    if (result) return result;
                }
            }
            
            return null;
        }
        
        function ucs(start, end) {
            const queue = [[start, 0, [start]]]; // [node, cost, path]
            const visited = new Set();
            
            while (queue.length > 0) {
                queue.sort((a, b) => a[1] - b[1]); // Ordenar pelo custo
                const [node, cost, path] = queue.shift();
                
                if (node === end) {
                    return {
                        path: path,
                        cost: cost
                    };
                }
                
                if (!visited.has(node)) {
                    visited.add(node);
                    for (const neighbor in graph[node]) {
                        const newCost = cost + graph[node][neighbor];
                        const newPath = [...path, neighbor];
                        queue.push([neighbor, newCost, newPath]);
                    }
                }
            }
            return null;
        }
        
        function dls(start, end, limit, path = [], visited = new Set(), cost = 0) {
            path = [...path, start];
            
            if (start === end) {
                return {path: [...path], cost};
            }
            
            if (limit <= 0) {
                return null;
            }
            
            visited.add(start);
            
            for (const neighbor in graph[start]) {
                if (!visited.has(neighbor)) {
                    const newVisited = new Set([...visited]);
                    const result = dls(neighbor, end, limit - 1, [...path], newVisited, cost + graph[start][neighbor]);
                    if (result) return result;
                }
            }
            
            return null;
        }
        
        function iddfs(start, end, maxDepth) {
            for (let depth = 0; depth <= maxDepth; depth++) {
                const result = dls(start, end, depth);
                if (result) return result;
            }
            return null;
        }
        
        function greedyBestFirstSearch(start, end) {
            const queue = [[heuristic[start] || 0, start, [start]]]; // [heuristic, node, path]
            const visited = new Set();
            
            while (queue.length > 0) {
                queue.sort((a, b) => a[0] - b[0]); // Ordenar pela heurística
                const [_, node, path] = queue.shift();
                
                if (node === end) {
                    return {
                        path: path,
                        cost: calculateTotalCost(path)
                    };
                }
                
                if (!visited.has(node)) {
                    visited.add(node);
                    for (const neighbor in graph[node]) {
                        if (!visited.has(neighbor)) {
                            const h = heuristic[neighbor] || 0;
                            queue.push([h, neighbor, [...path, neighbor]]);
                        }
                    }
                }
            }
            return null;
        }
        
        function aStar(start, end) {
            const openSet = [start];
            const cameFrom = {};
            const gScore = {};
            const fScore = {};
            
            // Inicializar gScore e fScore
            for (const node in graph) {
                gScore[node] = Infinity;
                fScore[node] = Infinity;
            }
            
            gScore[start] = 0;
            fScore[start] = heuristic[start] || 0;
            
            while (openSet.length > 0) {
                // Encontrar o nó com menor fScore
                let current = openSet.reduce((a, b) => fScore[a] < fScore[b] ? a : b);
                
                if (current === end) {
                    // Reconstruir caminho
                    const path = [current];
                    while (cameFrom[current]) {
                        current = cameFrom[current];
                        path.unshift(current);
                    }
                    return {path, cost: gScore[end]};
                }
                
                openSet.splice(openSet.indexOf(current), 1);
                
                for (const neighbor in graph[current]) {
                    const tentativeGScore = gScore[current] + graph[current][neighbor];
                    
                    if (tentativeGScore < gScore[neighbor]) {
                        cameFrom[neighbor] = current;
                        gScore[neighbor] = tentativeGScore;
                        fScore[neighbor] = gScore[neighbor] + (heuristic[neighbor] || 0);
                        
                        if (!openSet.includes(neighbor)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return null;
        }
        
        // Executar busca
        document.getElementById('search-btn').addEventListener('click', function() {
            const start = document.getElementById('start').value;
            const end = document.getElementById('end').value;
            const algorithm = document.getElementById('algorithm').value;
            const resultContainer = document.getElementById('result-container');
            const pathEl = document.getElementById('path');
            const costEl = document.getElementById('cost');
            const detailsEl = document.getElementById('details');
            
            if (!start || !end || !algorithm) {
                alert('Por favor, selecione a cidade de partida, destino e um algoritmo');
                return;
            }
            
            if (!validateInput(start, end)) {
                return;
            }
            
            let result = null;
            
            // Executar o algoritmo selecionado
            switch (algorithm) {
                case 'bfs':
                    result = bfs(start, end);
                    detailsEl.textContent = "Busca em Largura (BFS): Explora todos os vizinhos do nó atual antes de avançar.";
                    break;
                case 'dfs':
                    result = dfs(start, end);
                    detailsEl.textContent = "Busca em Profundidade (DFS): Explora o caminho até o máximo possível antes de voltar.";
                    break;
                case 'ucs':
                    result = ucs(start, end);
                    detailsEl.textContent = "Busca de Custo Uniforme (UCS): Explora os caminhos por ordem de custo crescente.";
                    break;
                case 'dls':
                    const limit = parseInt(document.getElementById('depth-limit').value) || 3;
                    result = dls(start, end, limit);
                    detailsEl.textContent = `Busca em Profundidade Limitada (DLS): DFS com limite de profundidade ${limit}.`;
                    break;
                case 'iddfs':
                    const maxDepth = parseInt(document.getElementById('max-depth').value) || 10;
                    result = iddfs(start, end, maxDepth);
                    detailsEl.textContent = `Busca de Aprofundamento Iterativo (IDDFS): Executa DLS com profundidade crescente até ${maxDepth}.`;
                    break;
                case 'greedy':
                    result = greedyBestFirstSearch(start, end);
                    detailsEl.textContent = "Busca Gulosa (Greedy): Escolhe sempre o nó mais próximo do objetivo com base na heurística.";
                    break;
                case 'astar':
                    result = aStar(start, end);
                    detailsEl.textContent = "A* (A-Star): Combina custo real do caminho com heurística para encontrar o caminho ótimo.";
                    break;
            }
            
            // Exibir resultado
            if (result) {
                pathEl.textContent = "Caminho encontrado: " + result.path.join(' → ');
                costEl.textContent = `Custo total: ${result.cost} km`;
                resultContainer.classList.remove('hidden');
            } else {
                pathEl.textContent = "Nenhum caminho encontrado";
                costEl.textContent = "";
                resultContainer.classList.remove('hidden');
            }
        });
        
        // Limpar resultados
        document.getElementById('clear-btn').addEventListener('click', function() {
            document.getElementById('result-container').classList.add('hidden');
            document.getElementById('algorithm').value = '';
            document.getElementById('dls-params').style.display = 'none';
            document.getElementById('iddfs-params').style.display = 'none';
        });
        
        // Inicializar a página
        document.addEventListener('DOMContentLoaded', function() {
            populateCityDropdowns();
        });
    </script>
</body>
</html>
